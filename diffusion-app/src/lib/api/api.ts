/* tslint:disable */
/* eslint-disable */
/**
 * FastAPI
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 0.1.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * 
 * @export
 * @interface ArtistItem
 */
export interface ArtistItem {
    /**
     * 
     * @type {string}
     * @memberof ArtistItem
     */
    'name': string;
    /**
     * 
     * @type {number}
     * @memberof ArtistItem
     */
    'score': number;
    /**
     * 
     * @type {string}
     * @memberof ArtistItem
     */
    'category': string;
}
/**
 * 
 * @export
 * @interface ExtrasBatchImagesRequest
 */
export interface ExtrasBatchImagesRequest {
    /**
     * Sets the resize mode: 0 to upscale by upscaling_resize amount, 1 to upscale up to upscaling_resize_h x upscaling_resize_w.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'resize_mode'?: ExtrasBatchImagesRequestResizeModeEnum;
    /**
     * Should the backend return the generated image?
     * @type {boolean}
     * @memberof ExtrasBatchImagesRequest
     */
    'show_extras_results'?: boolean;
    /**
     * Sets the visibility of GFPGAN, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'gfpgan_visibility'?: number;
    /**
     * Sets the visibility of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'codeformer_visibility'?: number;
    /**
     * Sets the weight of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'codeformer_weight'?: number;
    /**
     * By how much to upscale the image, only used when resize_mode=0.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaling_resize'?: number;
    /**
     * Target width for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaling_resize_w'?: number;
    /**
     * Target height for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaling_resize_h'?: number;
    /**
     * Should the upscaler crop the image to fit in the choosen size?
     * @type {boolean}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaling_crop'?: boolean;
    /**
     * The name of the main upscaler to use, it has to be one of this list: None , Lanczos , Nearest , LDSR , ESRGAN_4x , ScuNET GAN , ScuNET PSNR , SwinIR 4x
     * @type {string}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaler_1'?: string;
    /**
     * The name of the secondary upscaler to use, it has to be one of this list: None , Lanczos , Nearest , LDSR , ESRGAN_4x , ScuNET GAN , ScuNET PSNR , SwinIR 4x
     * @type {string}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscaler_2'?: string;
    /**
     * Sets the visibility of secondary upscaler, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasBatchImagesRequest
     */
    'extras_upscaler_2_visibility'?: number;
    /**
     * Should the upscaler run before restoring faces?
     * @type {boolean}
     * @memberof ExtrasBatchImagesRequest
     */
    'upscale_first'?: boolean;
    /**
     * List of images to work on. Must be Base64 strings
     * @type {Array<FileData>}
     * @memberof ExtrasBatchImagesRequest
     */
    'imageList': Array<FileData>;
}

export const ExtrasBatchImagesRequestResizeModeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type ExtrasBatchImagesRequestResizeModeEnum = typeof ExtrasBatchImagesRequestResizeModeEnum[keyof typeof ExtrasBatchImagesRequestResizeModeEnum];

/**
 * 
 * @export
 * @interface ExtrasBatchImagesResponse
 */
export interface ExtrasBatchImagesResponse {
    /**
     * A series of HTML tags containing the process info.
     * @type {string}
     * @memberof ExtrasBatchImagesResponse
     */
    'html_info': string;
    /**
     * The generated images in base64 format.
     * @type {Array<string>}
     * @memberof ExtrasBatchImagesResponse
     */
    'images': Array<string>;
}
/**
 * 
 * @export
 * @interface ExtrasSingleImageRequest
 */
export interface ExtrasSingleImageRequest {
    /**
     * Sets the resize mode: 0 to upscale by upscaling_resize amount, 1 to upscale up to upscaling_resize_h x upscaling_resize_w.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'resize_mode'?: ExtrasSingleImageRequestResizeModeEnum;
    /**
     * Should the backend return the generated image?
     * @type {boolean}
     * @memberof ExtrasSingleImageRequest
     */
    'show_extras_results'?: boolean;
    /**
     * Sets the visibility of GFPGAN, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'gfpgan_visibility'?: number;
    /**
     * Sets the visibility of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'codeformer_visibility'?: number;
    /**
     * Sets the weight of CodeFormer, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'codeformer_weight'?: number;
    /**
     * By how much to upscale the image, only used when resize_mode=0.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaling_resize'?: number;
    /**
     * Target width for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaling_resize_w'?: number;
    /**
     * Target height for the upscaler to hit. Only used when resize_mode=1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaling_resize_h'?: number;
    /**
     * Should the upscaler crop the image to fit in the choosen size?
     * @type {boolean}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaling_crop'?: boolean;
    /**
     * The name of the main upscaler to use, it has to be one of this list: None , Lanczos , Nearest , LDSR , ESRGAN_4x , ScuNET GAN , ScuNET PSNR , SwinIR 4x
     * @type {string}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaler_1'?: string;
    /**
     * The name of the secondary upscaler to use, it has to be one of this list: None , Lanczos , Nearest , LDSR , ESRGAN_4x , ScuNET GAN , ScuNET PSNR , SwinIR 4x
     * @type {string}
     * @memberof ExtrasSingleImageRequest
     */
    'upscaler_2'?: string;
    /**
     * Sets the visibility of secondary upscaler, values should be between 0 and 1.
     * @type {number}
     * @memberof ExtrasSingleImageRequest
     */
    'extras_upscaler_2_visibility'?: number;
    /**
     * Should the upscaler run before restoring faces?
     * @type {boolean}
     * @memberof ExtrasSingleImageRequest
     */
    'upscale_first'?: boolean;
    /**
     * Image to work on, must be a Base64 string containing the image\'s data.
     * @type {string}
     * @memberof ExtrasSingleImageRequest
     */
    'image'?: string;
}

export const ExtrasSingleImageRequestResizeModeEnum = {
    NUMBER_0: 0,
    NUMBER_1: 1
} as const;

export type ExtrasSingleImageRequestResizeModeEnum = typeof ExtrasSingleImageRequestResizeModeEnum[keyof typeof ExtrasSingleImageRequestResizeModeEnum];

/**
 * 
 * @export
 * @interface ExtrasSingleImageResponse
 */
export interface ExtrasSingleImageResponse {
    /**
     * A series of HTML tags containing the process info.
     * @type {string}
     * @memberof ExtrasSingleImageResponse
     */
    'html_info': string;
    /**
     * The generated image in base64 format.
     * @type {string}
     * @memberof ExtrasSingleImageResponse
     */
    'image'?: string;
}
/**
 * 
 * @export
 * @interface FaceRestorerItem
 */
export interface FaceRestorerItem {
    /**
     * 
     * @type {string}
     * @memberof FaceRestorerItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof FaceRestorerItem
     */
    'cmd_dir'?: string;
}
/**
 * 
 * @export
 * @interface FileData
 */
export interface FileData {
    /**
     * Base64 representation of the file
     * @type {string}
     * @memberof FileData
     */
    'data': string;
    /**
     * 
     * @type {string}
     * @memberof FileData
     */
    'name': string;
}
/**
 * 
 * @export
 * @interface Flags
 */
export interface Flags {
    /**
     * path to config which constructs model
     * @type {string}
     * @memberof Flags
     */
    'config'?: string;
    /**
     * path to checkpoint of stable diffusion model; if specified, this checkpoint will be added to the list of checkpoints and loaded
     * @type {string}
     * @memberof Flags
     */
    'ckpt'?: string;
    /**
     * Path to directory with stable diffusion checkpoints
     * @type {string}
     * @memberof Flags
     */
    'ckpt_dir'?: string;
    /**
     * GFPGAN directory
     * @type {string}
     * @memberof Flags
     */
    'gfpgan_dir'?: string;
    /**
     * GFPGAN model file name
     * @type {string}
     * @memberof Flags
     */
    'gfpgan_model'?: string;
    /**
     * do not switch the model to 16-bit floats
     * @type {boolean}
     * @memberof Flags
     */
    'no_half'?: boolean;
    /**
     * do not switch the VAE model to 16-bit floats
     * @type {boolean}
     * @memberof Flags
     */
    'no_half_vae'?: boolean;
    /**
     * do not hide progressbar in gradio UI (we hide it because it slows down ML if you have hardware acceleration in browser)
     * @type {boolean}
     * @memberof Flags
     */
    'no_progressbar_hiding'?: boolean;
    /**
     * maximum batch count value for the UI
     * @type {number}
     * @memberof Flags
     */
    'max_batch_count'?: number;
    /**
     * embeddings directory for textual inversion (default: embeddings)
     * @type {string}
     * @memberof Flags
     */
    'embeddings_dir'?: string;
    /**
     * hypernetwork directory
     * @type {string}
     * @memberof Flags
     */
    'hypernetwork_dir'?: string;
    /**
     * localizations directory
     * @type {string}
     * @memberof Flags
     */
    'localizations_dir'?: string;
    /**
     * allow custom script execution from webui
     * @type {boolean}
     * @memberof Flags
     */
    'allow_code'?: boolean;
    /**
     * enable stable diffusion model optimizations for sacrificing a little speed for low VRM usage
     * @type {boolean}
     * @memberof Flags
     */
    'medvram'?: boolean;
    /**
     * enable stable diffusion model optimizations for sacrificing a lot of speed for very low VRM usage
     * @type {boolean}
     * @memberof Flags
     */
    'lowvram'?: boolean;
    /**
     * load stable diffusion checkpoint weights to VRAM instead of RAM
     * @type {boolean}
     * @memberof Flags
     */
    'lowram'?: boolean;
    /**
     * disables cond/uncond batching that is enabled to save memory with --medvram or --lowvram
     * @type {boolean}
     * @memberof Flags
     */
    'always_batch_cond_uncond'?: boolean;
    /**
     * does not do anything.
     * @type {boolean}
     * @memberof Flags
     */
    'unload_gfpgan'?: boolean;
    /**
     * evaluate at this precision
     * @type {string}
     * @memberof Flags
     */
    'precision'?: string;
    /**
     * use share=True for gradio and make the UI accessible through their site
     * @type {boolean}
     * @memberof Flags
     */
    'share'?: boolean;
    /**
     * ngrok authtoken, alternative to gradio --share
     * @type {string}
     * @memberof Flags
     */
    'ngrok'?: string;
    /**
     * The region in which ngrok should start.
     * @type {string}
     * @memberof Flags
     */
    'ngrok_region'?: string;
    /**
     * enable extensions tab regardless of other options
     * @type {boolean}
     * @memberof Flags
     */
    'enable_insecure_extension_access'?: boolean;
    /**
     * Path to directory with codeformer model file(s).
     * @type {string}
     * @memberof Flags
     */
    'codeformer_models_path'?: string;
    /**
     * Path to directory with GFPGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    'gfpgan_models_path'?: string;
    /**
     * Path to directory with ESRGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    'esrgan_models_path'?: string;
    /**
     * Path to directory with BSRGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    'bsrgan_models_path'?: string;
    /**
     * Path to directory with RealESRGAN model file(s).
     * @type {string}
     * @memberof Flags
     */
    'realesrgan_models_path'?: string;
    /**
     * Path to directory with ScuNET model file(s).
     * @type {string}
     * @memberof Flags
     */
    'scunet_models_path'?: string;
    /**
     * Path to directory with SwinIR model file(s).
     * @type {string}
     * @memberof Flags
     */
    'swinir_models_path'?: string;
    /**
     * Path to directory with LDSR model file(s).
     * @type {string}
     * @memberof Flags
     */
    'ldsr_models_path'?: string;
    /**
     * Path to directory with CLIP model file(s).
     * @type {string}
     * @memberof Flags
     */
    'clip_models_path'?: string;
    /**
     * enable xformers for cross attention layers
     * @type {boolean}
     * @memberof Flags
     */
    'xformers'?: boolean;
    /**
     * enable xformers for cross attention layers regardless of whether the checking code thinks you can run it; do not make bug reports if this fails to work
     * @type {boolean}
     * @memberof Flags
     */
    'force_enable_xformers'?: boolean;
    /**
     * enable deepdanbooru interrogator
     * @type {boolean}
     * @memberof Flags
     */
    'deepdanbooru'?: boolean;
    /**
     * force-enables Doggettx\'s cross-attention layer optimization. By default, it\'s on for torch cuda.
     * @type {boolean}
     * @memberof Flags
     */
    'opt_split_attention'?: boolean;
    /**
     * force-enables InvokeAI\'s cross-attention layer optimization. By default, it\'s on when cuda is unavailable.
     * @type {boolean}
     * @memberof Flags
     */
    'opt_split_attention_invokeai'?: boolean;
    /**
     * enable older version of split attention optimization that does not consume all the VRAM it can find
     * @type {boolean}
     * @memberof Flags
     */
    'opt_split_attention_v1'?: boolean;
    /**
     * force-disables cross-attention layer optimization
     * @type {boolean}
     * @memberof Flags
     */
    'disable_opt_split_attention'?: boolean;
    /**
     * use CPU as torch device for specified modules
     * @type {Array<any>}
     * @memberof Flags
     */
    'use_cpu'?: Array<any>;
    /**
     * launch gradio with 0.0.0.0 as server name, allowing to respond to network requests
     * @type {boolean}
     * @memberof Flags
     */
    'listen'?: boolean;
    /**
     * launch gradio with given server port, you need root/admin rights for ports < 1024, defaults to 7860 if available
     * @type {string}
     * @memberof Flags
     */
    'port'?: string;
    /**
     * does not do anything
     * @type {boolean}
     * @memberof Flags
     */
    'show_negative_prompt'?: boolean;
    /**
     * filename to use for ui configuration
     * @type {string}
     * @memberof Flags
     */
    'ui_config_file'?: string;
    /**
     * hide directory configuration from webui
     * @type {boolean}
     * @memberof Flags
     */
    'hide_ui_dir_config'?: boolean;
    /**
     * disable editing settings
     * @type {boolean}
     * @memberof Flags
     */
    'freeze_settings'?: boolean;
    /**
     * filename to use for ui settings
     * @type {string}
     * @memberof Flags
     */
    'ui_settings_file'?: string;
    /**
     * launch gradio with --debug option
     * @type {boolean}
     * @memberof Flags
     */
    'gradio_debug'?: boolean;
    /**
     * set gradio authentication like \"username:password\"; or comma-delimit multiple like \"u1:p1,u2:p2,u3:p3\"
     * @type {string}
     * @memberof Flags
     */
    'gradio_auth'?: string;
    /**
     * gradio image uploader tool: can be either editor for ctopping, or color-sketch for drawing
     * @type {string}
     * @memberof Flags
     */
    'gradio_img2img_tool'?: string;
    /**
     * change memory type for stable diffusion to channels last
     * @type {boolean}
     * @memberof Flags
     */
    'opt_channelslast'?: boolean;
    /**
     * filename to use for styles
     * @type {string}
     * @memberof Flags
     */
    'styles_file'?: string;
    /**
     * open the webui URL in the system\'s default browser upon launch
     * @type {boolean}
     * @memberof Flags
     */
    'autolaunch'?: boolean;
    /**
     * launches the UI with light or dark theme
     * @type {string}
     * @memberof Flags
     */
    'theme'?: string;
    /**
     * use textbox for seeds in UI (no up/down, but possible to input long seeds)
     * @type {boolean}
     * @memberof Flags
     */
    'use_textbox_seed'?: boolean;
    /**
     * do not output progressbars to console
     * @type {boolean}
     * @memberof Flags
     */
    'disable_console_progressbars'?: boolean;
    /**
     * print prompts to console when generating with txt2img and img2img
     * @type {boolean}
     * @memberof Flags
     */
    'enable_console_prompts'?: boolean;
    /**
     * Path to Variational Autoencoders model
     * @type {string}
     * @memberof Flags
     */
    'vae_path'?: string;
    /**
     * disable checking pytorch models for malicious code
     * @type {boolean}
     * @memberof Flags
     */
    'disable_safe_unpickle'?: boolean;
    /**
     * use api=True to launch the api with the webui
     * @type {boolean}
     * @memberof Flags
     */
    'api'?: boolean;
    /**
     * use api=True to launch the api instead of the webui
     * @type {boolean}
     * @memberof Flags
     */
    'nowebui'?: boolean;
    /**
     * Don\'t load model to quickly launch UI
     * @type {boolean}
     * @memberof Flags
     */
    'ui_debug_mode'?: boolean;
    /**
     * Select the default CUDA device to use (export CUDA_VISIBLE_DEVICES=0,1,etc might be needed before)
     * @type {string}
     * @memberof Flags
     */
    'device_id'?: string;
    /**
     * Administrator rights
     * @type {boolean}
     * @memberof Flags
     */
    'administrator'?: boolean;
    /**
     * Allowed CORS origins
     * @type {string}
     * @memberof Flags
     */
    'cors_allow_origins'?: string;
    /**
     * Partially enables TLS, requires --tls-certfile to fully function
     * @type {string}
     * @memberof Flags
     */
    'tls_keyfile'?: string;
    /**
     * Partially enables TLS, requires --tls-keyfile to fully function
     * @type {string}
     * @memberof Flags
     */
    'tls_certfile'?: string;
    /**
     * Sets hostname of server
     * @type {string}
     * @memberof Flags
     */
    'server_name'?: string;
}
/**
 * 
 * @export
 * @interface HTTPValidationError
 */
export interface HTTPValidationError {
    /**
     * 
     * @type {Array<ValidationError>}
     * @memberof HTTPValidationError
     */
    'detail'?: Array<ValidationError>;
}
/**
 * 
 * @export
 * @interface HypernetworkItem
 */
export interface HypernetworkItem {
    /**
     * 
     * @type {string}
     * @memberof HypernetworkItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof HypernetworkItem
     */
    'path'?: string;
}
/**
 * 
 * @export
 * @interface ImageToImageResponse
 */
export interface ImageToImageResponse {
    /**
     * The generated image in base64 format.
     * @type {Array<string>}
     * @memberof ImageToImageResponse
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof ImageToImageResponse
     */
    'parameters': object;
    /**
     * 
     * @type {string}
     * @memberof ImageToImageResponse
     */
    'info': string;
}
/**
 * 
 * @export
 * @interface InterrogateRequest
 */
export interface InterrogateRequest {
    /**
     * Image to work on, must be a Base64 string containing the image\'s data.
     * @type {string}
     * @memberof InterrogateRequest
     */
    'image'?: string;
    /**
     * The interrogate model used.
     * @type {string}
     * @memberof InterrogateRequest
     */
    'model'?: string;
}
/**
 * 
 * @export
 * @interface LocationInner
 */
export interface LocationInner {
}
/**
 * 
 * @export
 * @interface Options
 */
export interface Options {
    /**
     * Always save all generated images
     * @type {boolean}
     * @memberof Options
     */
    'samples_save'?: boolean;
    /**
     * File format for images
     * @type {string}
     * @memberof Options
     */
    'samples_format'?: string;
    /**
     * Images filename pattern
     * @type {string}
     * @memberof Options
     */
    'samples_filename_pattern'?: string;
    /**
     * Add number to filename when saving
     * @type {boolean}
     * @memberof Options
     */
    'save_images_add_number'?: boolean;
    /**
     * Always save all generated image grids
     * @type {boolean}
     * @memberof Options
     */
    'grid_save'?: boolean;
    /**
     * File format for grids
     * @type {string}
     * @memberof Options
     */
    'grid_format'?: string;
    /**
     * Add extended info (seed, prompt) to filename when saving grid
     * @type {boolean}
     * @memberof Options
     */
    'grid_extended_filename'?: boolean;
    /**
     * Do not save grids consisting of one picture
     * @type {boolean}
     * @memberof Options
     */
    'grid_only_if_multiple'?: boolean;
    /**
     * Prevent empty spots in grid (when set to autodetect)
     * @type {boolean}
     * @memberof Options
     */
    'grid_prevent_empty_spots'?: boolean;
    /**
     * Grid row count; use -1 for autodetect and 0 for it to be same as batch size
     * @type {number}
     * @memberof Options
     */
    'n_rows'?: number;
    /**
     * Save text information about generation parameters as chunks to png files
     * @type {boolean}
     * @memberof Options
     */
    'enable_pnginfo'?: boolean;
    /**
     * Create a text file next to every image with generation parameters.
     * @type {boolean}
     * @memberof Options
     */
    'save_txt'?: boolean;
    /**
     * Save a copy of image before doing face restoration.
     * @type {boolean}
     * @memberof Options
     */
    'save_images_before_face_restoration'?: boolean;
    /**
     * Save a copy of image before applying highres fix.
     * @type {boolean}
     * @memberof Options
     */
    'save_images_before_highres_fix'?: boolean;
    /**
     * Save a copy of image before applying color correction to img2img results
     * @type {boolean}
     * @memberof Options
     */
    'save_images_before_color_correction'?: boolean;
    /**
     * Quality for saved jpeg images
     * @type {number}
     * @memberof Options
     */
    'jpeg_quality'?: number;
    /**
     * If PNG image is larger than 4MB or any dimension is larger than 4000, downscale and save copy as JPG
     * @type {boolean}
     * @memberof Options
     */
    'export_for_4chan'?: boolean;
    /**
     * Use original name for output filename during batch process in extras tab
     * @type {boolean}
     * @memberof Options
     */
    'use_original_name_batch'?: boolean;
    /**
     * When using \'Save\' button, only save a single selected image
     * @type {boolean}
     * @memberof Options
     */
    'save_selected_only'?: boolean;
    /**
     * Do not add watermark to images
     * @type {boolean}
     * @memberof Options
     */
    'do_not_add_watermark'?: boolean;
    /**
     * Output directory for images; if empty, defaults to three directories below
     * @type {string}
     * @memberof Options
     */
    'outdir_samples'?: string;
    /**
     * Output directory for txt2img images
     * @type {string}
     * @memberof Options
     */
    'outdir_txt2img_samples'?: string;
    /**
     * Output directory for img2img images
     * @type {string}
     * @memberof Options
     */
    'outdir_img2img_samples'?: string;
    /**
     * Output directory for images from extras tab
     * @type {string}
     * @memberof Options
     */
    'outdir_extras_samples'?: string;
    /**
     * Output directory for grids; if empty, defaults to two directories below
     * @type {string}
     * @memberof Options
     */
    'outdir_grids'?: string;
    /**
     * Output directory for txt2img grids
     * @type {string}
     * @memberof Options
     */
    'outdir_txt2img_grids'?: string;
    /**
     * Output directory for img2img grids
     * @type {string}
     * @memberof Options
     */
    'outdir_img2img_grids'?: string;
    /**
     * Directory for saving images using the Save button
     * @type {string}
     * @memberof Options
     */
    'outdir_save'?: string;
    /**
     * Save images to a subdirectory
     * @type {boolean}
     * @memberof Options
     */
    'save_to_dirs'?: boolean;
    /**
     * Save grids to a subdirectory
     * @type {boolean}
     * @memberof Options
     */
    'grid_save_to_dirs'?: boolean;
    /**
     * When using \"Save\" button, save images to a subdirectory
     * @type {boolean}
     * @memberof Options
     */
    'use_save_to_dirs_for_ui'?: boolean;
    /**
     * Directory name pattern
     * @type {string}
     * @memberof Options
     */
    'directories_filename_pattern'?: string;
    /**
     * Max prompt words for [prompt_words] pattern
     * @type {number}
     * @memberof Options
     */
    'directories_max_prompt_words'?: number;
    /**
     * Tile size for ESRGAN upscalers. 0 = no tiling.
     * @type {number}
     * @memberof Options
     */
    'ESRGAN_tile'?: number;
    /**
     * Tile overlap, in pixels for ESRGAN upscalers. Low values = visible seam.
     * @type {number}
     * @memberof Options
     */
    'ESRGAN_tile_overlap'?: number;
    /**
     * Select which Real-ESRGAN models to show in the web UI. (Requires restart)
     * @type {Array<any>}
     * @memberof Options
     */
    'realesrgan_enabled_models'?: Array<any>;
    /**
     * Tile size for all SwinIR.
     * @type {number}
     * @memberof Options
     */
    'SWIN_tile'?: number;
    /**
     * Tile overlap, in pixels for SwinIR. Low values = visible seam.
     * @type {number}
     * @memberof Options
     */
    'SWIN_tile_overlap'?: number;
    /**
     * LDSR processing steps. Lower = faster
     * @type {number}
     * @memberof Options
     */
    'ldsr_steps'?: number;
    /**
     * Upscaler for img2img
     * @type {null}
     * @memberof Options
     */
    'upscaler_for_img2img'?: null;
    /**
     * Upscale latent space image when doing hires. fix
     * @type {boolean}
     * @memberof Options
     */
    'use_scale_latent_for_hires_fix'?: boolean;
    /**
     * Face restoration model
     * @type {null}
     * @memberof Options
     */
    'face_restoration_model'?: null;
    /**
     * CodeFormer weight parameter; 0 = maximum effect; 1 = minimum effect
     * @type {number}
     * @memberof Options
     */
    'code_former_weight'?: number;
    /**
     * Move face restoration model from VRAM into RAM after processing
     * @type {boolean}
     * @memberof Options
     */
    'face_restoration_unload'?: boolean;
    /**
     * VRAM usage polls per second during generation. Set to 0 to disable.
     * @type {number}
     * @memberof Options
     */
    'memmon_poll_rate'?: number;
    /**
     * Always print all generation info to standard output
     * @type {boolean}
     * @memberof Options
     */
    'samples_log_stdout'?: boolean;
    /**
     * Add a second progress bar to the console that shows progress for an entire job.
     * @type {boolean}
     * @memberof Options
     */
    'multiple_tqdm'?: boolean;
    /**
     * Move VAE and CLIP to RAM when training if possible. Saves VRAM.
     * @type {boolean}
     * @memberof Options
     */
    'unload_models_when_training'?: boolean;
    /**
     * Filename word regex
     * @type {string}
     * @memberof Options
     */
    'dataset_filename_word_regex'?: string;
    /**
     * Filename join string
     * @type {string}
     * @memberof Options
     */
    'dataset_filename_join_string'?: string;
    /**
     * Number of repeats for a single input image per epoch; used only for displaying epoch number
     * @type {number}
     * @memberof Options
     */
    'training_image_repeats_per_epoch'?: number;
    /**
     * Save an csv containing the loss to log directory every N steps, 0 to disable
     * @type {number}
     * @memberof Options
     */
    'training_write_csv_every'?: number;
    /**
     * Use cross attention optimizations while training
     * @type {boolean}
     * @memberof Options
     */
    'training_xattention_optimizations'?: boolean;
    /**
     * Stable Diffusion checkpoint
     * @type {string}
     * @memberof Options
     */
    'sd_model_checkpoint'?: string;
    /**
     * Checkpoints to cache in RAM
     * @type {number}
     * @memberof Options
     */
    'sd_checkpoint_cache'?: number;
    /**
     * SD VAE
     * @type {string}
     * @memberof Options
     */
    'sd_vae'?: string;
    /**
     * Hypernetwork
     * @type {string}
     * @memberof Options
     */
    'sd_hypernetwork'?: string;
    /**
     * Hypernetwork strength
     * @type {number}
     * @memberof Options
     */
    'sd_hypernetwork_strength'?: number;
    /**
     * Inpainting conditioning mask strength
     * @type {number}
     * @memberof Options
     */
    'inpainting_mask_weight'?: number;
    /**
     * Apply color correction to img2img results to match original colors.
     * @type {boolean}
     * @memberof Options
     */
    'img2img_color_correction'?: boolean;
    /**
     * With img2img, do exactly the amount of steps the slider specifies (normally you\'d do less with less denoising).
     * @type {boolean}
     * @memberof Options
     */
    'img2img_fix_steps'?: boolean;
    /**
     * Enable quantization in K samplers for sharper and cleaner results. This may change existing seeds. Requires restart to apply.
     * @type {boolean}
     * @memberof Options
     */
    'enable_quantization'?: boolean;
    /**
     * Emphasis: use (text) to make model pay more attention to text and [text] to make it pay less attention
     * @type {boolean}
     * @memberof Options
     */
    'enable_emphasis'?: boolean;
    /**
     * Use old emphasis implementation. Can be useful to reproduce old seeds.
     * @type {boolean}
     * @memberof Options
     */
    'use_old_emphasis_implementation'?: boolean;
    /**
     * Make K-diffusion samplers produce same images in a batch as when making a single image
     * @type {boolean}
     * @memberof Options
     */
    'enable_batch_seeds'?: boolean;
    /**
     * Increase coherency by padding from the last comma within n tokens when using more than 75 tokens
     * @type {number}
     * @memberof Options
     */
    'comma_padding_backtrack'?: number;
    /**
     * Filter NSFW content
     * @type {boolean}
     * @memberof Options
     */
    'filter_nsfw'?: boolean;
    /**
     * Stop At last layers of CLIP model
     * @type {number}
     * @memberof Options
     */
    'CLIP_stop_at_last_layers'?: number;
    /**
     * Allowed categories for random artists selection when using the Roll button
     * @type {Array<any>}
     * @memberof Options
     */
    'random_artist_categories'?: Array<any>;
    /**
     * Interrogate: keep models in VRAM
     * @type {boolean}
     * @memberof Options
     */
    'interrogate_keep_models_in_memory'?: boolean;
    /**
     * Interrogate: use artists from artists.csv
     * @type {boolean}
     * @memberof Options
     */
    'interrogate_use_builtin_artists'?: boolean;
    /**
     * Interrogate: include ranks of model tags matches in results (Has no effect on caption-based interrogators).
     * @type {boolean}
     * @memberof Options
     */
    'interrogate_return_ranks'?: boolean;
    /**
     * Interrogate: num_beams for BLIP
     * @type {number}
     * @memberof Options
     */
    'interrogate_clip_num_beams'?: number;
    /**
     * Interrogate: minimum description length (excluding artists, etc..)
     * @type {number}
     * @memberof Options
     */
    'interrogate_clip_min_length'?: number;
    /**
     * Interrogate: maximum description length
     * @type {number}
     * @memberof Options
     */
    'interrogate_clip_max_length'?: number;
    /**
     * CLIP: maximum number of lines in text file (0 = No limit)
     * @type {number}
     * @memberof Options
     */
    'interrogate_clip_dict_limit'?: number;
    /**
     * Interrogate: deepbooru score threshold
     * @type {number}
     * @memberof Options
     */
    'interrogate_deepbooru_score_threshold'?: number;
    /**
     * Interrogate: deepbooru sort alphabetically
     * @type {boolean}
     * @memberof Options
     */
    'deepbooru_sort_alpha'?: boolean;
    /**
     * use spaces for tags in deepbooru
     * @type {boolean}
     * @memberof Options
     */
    'deepbooru_use_spaces'?: boolean;
    /**
     * escape (\\) brackets in deepbooru (so they are used as literal brackets and not for emphasis)
     * @type {boolean}
     * @memberof Options
     */
    'deepbooru_escape'?: boolean;
    /**
     * Show progressbar
     * @type {boolean}
     * @memberof Options
     */
    'show_progressbar'?: boolean;
    /**
     * Show image creation progress every N sampling steps. Set to 0 to disable. Set to -1 to show after completion of batch.
     * @type {number}
     * @memberof Options
     */
    'show_progress_every_n_steps'?: number;
    /**
     * Show previews of all images generated in a batch as a grid
     * @type {boolean}
     * @memberof Options
     */
    'show_progress_grid'?: boolean;
    /**
     * Show grid in results for web
     * @type {boolean}
     * @memberof Options
     */
    'return_grid'?: boolean;
    /**
     * Do not show any images in results for web
     * @type {boolean}
     * @memberof Options
     */
    'do_not_show_images'?: boolean;
    /**
     * Add model hash to generation information
     * @type {boolean}
     * @memberof Options
     */
    'add_model_hash_to_info'?: boolean;
    /**
     * Add model name to generation information
     * @type {boolean}
     * @memberof Options
     */
    'add_model_name_to_info'?: boolean;
    /**
     * When reading generation parameters from text into UI (from PNG info or pasted text), do not change the selected model/checkpoint.
     * @type {boolean}
     * @memberof Options
     */
    'disable_weights_auto_swap'?: boolean;
    /**
     * Send seed when sending prompt or image to other interface
     * @type {boolean}
     * @memberof Options
     */
    'send_seed'?: boolean;
    /**
     * Font for image grids that have text
     * @type {string}
     * @memberof Options
     */
    'font'?: string;
    /**
     * Enable full page image viewer
     * @type {boolean}
     * @memberof Options
     */
    'js_modal_lightbox'?: boolean;
    /**
     * Show images zoomed in by default in full page image viewer
     * @type {boolean}
     * @memberof Options
     */
    'js_modal_lightbox_initially_zoomed'?: boolean;
    /**
     * Show generation progress in window title.
     * @type {boolean}
     * @memberof Options
     */
    'show_progress_in_title'?: boolean;
    /**
     * Quicksettings list
     * @type {string}
     * @memberof Options
     */
    'quicksettings'?: string;
    /**
     * Localization (requires restart)
     * @type {string}
     * @memberof Options
     */
    'localization'?: string;
    /**
     * Hide samplers in user interface (requires restart)
     * @type {Array<any>}
     * @memberof Options
     */
    'hide_samplers'?: Array<any>;
    /**
     * eta (noise multiplier) for DDIM
     * @type {number}
     * @memberof Options
     */
    'eta_ddim'?: number;
    /**
     * eta (noise multiplier) for ancestral samplers
     * @type {number}
     * @memberof Options
     */
    'eta_ancestral'?: number;
    /**
     * img2img DDIM discretize
     * @type {string}
     * @memberof Options
     */
    'ddim_discretize'?: string;
    /**
     * sigma churn
     * @type {number}
     * @memberof Options
     */
    's_churn'?: number;
    /**
     * sigma tmin
     * @type {number}
     * @memberof Options
     */
    's_tmin'?: number;
    /**
     * sigma noise
     * @type {number}
     * @memberof Options
     */
    's_noise'?: number;
    /**
     * Eta noise seed delta
     * @type {number}
     * @memberof Options
     */
    'eta_noise_seed_delta'?: number;
    /**
     * Disable those extensions
     * @type {Array<any>}
     * @memberof Options
     */
    'disabled_extensions'?: Array<any>;
}
/**
 * 
 * @export
 * @interface PNGInfoRequest
 */
export interface PNGInfoRequest {
    /**
     * The base64 encoded PNG image
     * @type {string}
     * @memberof PNGInfoRequest
     */
    'image': string;
}
/**
 * 
 * @export
 * @interface PNGInfoResponse
 */
export interface PNGInfoResponse {
    /**
     * A string with all the info the image had
     * @type {string}
     * @memberof PNGInfoResponse
     */
    'info': string;
}
/**
 * 
 * @export
 * @interface ProgressResponse
 */
export interface ProgressResponse {
    /**
     * The progress with a range of 0 to 1
     * @type {number}
     * @memberof ProgressResponse
     */
    'progress': number;
    /**
     * 
     * @type {number}
     * @memberof ProgressResponse
     */
    'eta_relative': number;
    /**
     * The current state snapshot
     * @type {object}
     * @memberof ProgressResponse
     */
    'state': object;
    /**
     * The current image in base64 format. opts.show_progress_every_n_steps is required for this to work.
     * @type {string}
     * @memberof ProgressResponse
     */
    'current_image'?: string;
}
/**
 * 
 * @export
 * @interface PromptStyleItem
 */
export interface PromptStyleItem {
    /**
     * 
     * @type {string}
     * @memberof PromptStyleItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof PromptStyleItem
     */
    'prompt'?: string;
    /**
     * 
     * @type {string}
     * @memberof PromptStyleItem
     */
    'negative_prompt'?: string;
}
/**
 * 
 * @export
 * @interface RealesrganItem
 */
export interface RealesrganItem {
    /**
     * 
     * @type {string}
     * @memberof RealesrganItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof RealesrganItem
     */
    'path'?: string;
    /**
     * 
     * @type {number}
     * @memberof RealesrganItem
     */
    'scale'?: number;
}
/**
 * 
 * @export
 * @interface SDModelItem
 */
export interface SDModelItem {
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'title': string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'model_name': string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'hash': string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'filename': string;
    /**
     * 
     * @type {string}
     * @memberof SDModelItem
     */
    'config': string;
}
/**
 * 
 * @export
 * @interface SamplerItem
 */
export interface SamplerItem {
    /**
     * 
     * @type {string}
     * @memberof SamplerItem
     */
    'name': string;
    /**
     * 
     * @type {Array<string>}
     * @memberof SamplerItem
     */
    'aliases': Array<string>;
    /**
     * 
     * @type {{ [key: string]: string; }}
     * @memberof SamplerItem
     */
    'options': { [key: string]: string; };
}
/**
 * 
 * @export
 * @interface StableDiffusionProcessingImg2Img
 */
export interface StableDiffusionProcessingImg2Img {
    /**
     * 
     * @type {Array<any>}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'init_images'?: Array<any>;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'resize_mode'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'denoising_strength'?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'mask'?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'mask_blur'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'inpainting_fill'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'inpaint_full_res'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'inpaint_full_res_padding'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'inpainting_mask_invert'?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'prompt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'styles'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'seed'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'subseed'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'subseed_strength'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'seed_resize_from_h'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'seed_resize_from_w'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'batch_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'n_iter'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'steps'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'cfg_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'height'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'restore_faces'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'tiling'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'negative_prompt'?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'eta'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    's_churn'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    's_tmax'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    's_tmin'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingImg2Img
     */
    's_noise'?: number;
    /**
     * 
     * @type {object}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'override_settings'?: object;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'sampler_index'?: string;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingImg2Img
     */
    'include_init_images'?: boolean;
}
/**
 * 
 * @export
 * @interface StableDiffusionProcessingTxt2Img
 */
export interface StableDiffusionProcessingTxt2Img {
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'enable_hr'?: boolean;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'denoising_strength'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'firstphase_width'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'firstphase_height'?: number;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'prompt'?: string;
    /**
     * 
     * @type {Array<string>}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'styles'?: Array<string>;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'seed'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'subseed'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'subseed_strength'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'seed_resize_from_h'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'seed_resize_from_w'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'batch_size'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'n_iter'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'steps'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'cfg_scale'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'width'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'height'?: number;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'restore_faces'?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'tiling'?: boolean;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'negative_prompt'?: string;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'eta'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    's_churn'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    's_tmax'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    's_tmin'?: number;
    /**
     * 
     * @type {number}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    's_noise'?: number;
    /**
     * 
     * @type {object}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'override_settings'?: object;
    /**
     * 
     * @type {string}
     * @memberof StableDiffusionProcessingTxt2Img
     */
    'sampler_index'?: string;
}
/**
 * 
 * @export
 * @interface TextToImageResponse
 */
export interface TextToImageResponse {
    /**
     * The generated image in base64 format.
     * @type {Array<string>}
     * @memberof TextToImageResponse
     */
    'images'?: Array<string>;
    /**
     * 
     * @type {object}
     * @memberof TextToImageResponse
     */
    'parameters': object;
    /**
     * 
     * @type {string}
     * @memberof TextToImageResponse
     */
    'info': string;
}
/**
 * 
 * @export
 * @interface UpscalerItem
 */
export interface UpscalerItem {
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    'name': string;
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    'model_name'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    'model_path'?: string;
    /**
     * 
     * @type {string}
     * @memberof UpscalerItem
     */
    'model_url'?: string;
}
/**
 * 
 * @export
 * @interface ValidationError
 */
export interface ValidationError {
    /**
     * 
     * @type {Array<LocationInner>}
     * @memberof ValidationError
     */
    'loc': Array<LocationInner>;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'msg': string;
    /**
     * 
     * @type {string}
     * @memberof ValidationError
     */
    'type': string;
}

/**
 * DefaultApi - axios parameter creator
 * @export
 */
export const DefaultApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * 
         * @summary Extras Batch Images Api
         * @param {ExtrasBatchImagesRequest} extrasBatchImagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasBatchImagesApiSdapiV1ExtraBatchImagesPost: async (extrasBatchImagesRequest: ExtrasBatchImagesRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'extrasBatchImagesRequest' is not null or undefined
            assertParamExists('extrasBatchImagesApiSdapiV1ExtraBatchImagesPost', 'extrasBatchImagesRequest', extrasBatchImagesRequest)
            const localVarPath = `/sdapi/v1/extra-batch-images`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(extrasBatchImagesRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Extras Single Image Api
         * @param {ExtrasSingleImageRequest} extrasSingleImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasSingleImageApiSdapiV1ExtraSingleImagePost: async (extrasSingleImageRequest: ExtrasSingleImageRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'extrasSingleImageRequest' is not null or undefined
            assertParamExists('extrasSingleImageApiSdapiV1ExtraSingleImagePost', 'extrasSingleImageRequest', extrasSingleImageRequest)
            const localVarPath = `/sdapi/v1/extra-single-image`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(extrasSingleImageRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Artists Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistsCategoriesSdapiV1ArtistCategoriesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/artist-categories`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Artists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistsSdapiV1ArtistsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/artists`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Cmd Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmdFlagsSdapiV1CmdFlagsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/cmd-flags`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigSdapiV1OptionsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Face Restorers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaceRestorersSdapiV1FaceRestorersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/face-restorers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Hypernetworks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHypernetworksSdapiV1HypernetworksGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/hypernetworks`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Promp Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrompStylesSdapiV1PromptStylesGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/prompt-styles`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Realesrgan Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealesrganModelsSdapiV1RealesrganModelsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/realesrgan-models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Samplers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamplersSdapiV1SamplersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/samplers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Sd Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdModelsSdapiV1SdModelsGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/sd-models`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get Upscalers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpscalersSdapiV1UpscalersGet: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/upscalers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Img2Imgapi
         * @param {StableDiffusionProcessingImg2Img} stableDiffusionProcessingImg2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        img2imgapiSdapiV1Img2imgPost: async (stableDiffusionProcessingImg2Img: StableDiffusionProcessingImg2Img, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stableDiffusionProcessingImg2Img' is not null or undefined
            assertParamExists('img2imgapiSdapiV1Img2imgPost', 'stableDiffusionProcessingImg2Img', stableDiffusionProcessingImg2Img)
            const localVarPath = `/sdapi/v1/img2img`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(stableDiffusionProcessingImg2Img, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Interrogateapi
         * @param {InterrogateRequest} interrogateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrogateapiSdapiV1InterrogatePost: async (interrogateRequest: InterrogateRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'interrogateRequest' is not null or undefined
            assertParamExists('interrogateapiSdapiV1InterrogatePost', 'interrogateRequest', interrogateRequest)
            const localVarPath = `/sdapi/v1/interrogate`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(interrogateRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Interruptapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interruptapiSdapiV1InterruptPost: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/interrupt`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Pnginfoapi
         * @param {PNGInfoRequest} pNGInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pnginfoapiSdapiV1PngInfoPost: async (pNGInfoRequest: PNGInfoRequest, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'pNGInfoRequest' is not null or undefined
            assertParamExists('pnginfoapiSdapiV1PngInfoPost', 'pNGInfoRequest', pNGInfoRequest)
            const localVarPath = `/sdapi/v1/png-info`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(pNGInfoRequest, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Progressapi
         * @param {boolean} [skipCurrentImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiSdapiV1ProgressGet: async (skipCurrentImage?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/sdapi/v1/progress`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            if (skipCurrentImage !== undefined) {
                localVarQueryParameter['skip_current_image'] = skipCurrentImage;
            }



            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Set Config
         * @param {Options} options 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfigSdapiV1OptionsPost: async (options: Options, _options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'options' is not null or undefined
            assertParamExists('setConfigSdapiV1OptionsPost', 'options', options)
            const localVarPath = `/sdapi/v1/options`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ..._options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(options, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Text2Imgapi
         * @param {StableDiffusionProcessingTxt2Img} stableDiffusionProcessingTxt2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        text2imgapiSdapiV1Txt2imgPost: async (stableDiffusionProcessingTxt2Img: StableDiffusionProcessingTxt2Img, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'stableDiffusionProcessingTxt2Img' is not null or undefined
            assertParamExists('text2imgapiSdapiV1Txt2imgPost', 'stableDiffusionProcessingTxt2Img', stableDiffusionProcessingTxt2Img)
            const localVarPath = `/sdapi/v1/txt2img`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'POST', ...baseOptions, ...options };
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;



            localVarHeaderParameter['Content-Type'] = 'application/json';

            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };
            localVarRequestOptions.data = serializeDataIfNeeded(stableDiffusionProcessingTxt2Img, localVarRequestOptions, configuration)

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DefaultApi - functional programming interface
 * @export
 */
export const DefaultApiFp = function (configuration?: Configuration) {
    const localVarAxiosParamCreator = DefaultApiAxiosParamCreator(configuration)
    return {
        /**
         * 
         * @summary Extras Batch Images Api
         * @param {ExtrasBatchImagesRequest} extrasBatchImagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest: ExtrasBatchImagesRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtrasBatchImagesResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Extras Single Image Api
         * @param {ExtrasSingleImageRequest} extrasSingleImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest: ExtrasSingleImageRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ExtrasSingleImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Artists Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtistsCategoriesSdapiV1ArtistCategoriesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<string>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtistsCategoriesSdapiV1ArtistCategoriesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Artists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getArtistsSdapiV1ArtistsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ArtistItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getArtistsSdapiV1ArtistsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Cmd Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCmdFlagsSdapiV1CmdFlagsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Flags>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCmdFlagsSdapiV1CmdFlagsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getConfigSdapiV1OptionsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Options>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getConfigSdapiV1OptionsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Face Restorers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFaceRestorersSdapiV1FaceRestorersGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<FaceRestorerItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFaceRestorersSdapiV1FaceRestorersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Hypernetworks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHypernetworksSdapiV1HypernetworksGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<HypernetworkItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHypernetworksSdapiV1HypernetworksGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Promp Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPrompStylesSdapiV1PromptStylesGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<PromptStyleItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPrompStylesSdapiV1PromptStylesGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Realesrgan Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRealesrganModelsSdapiV1RealesrganModelsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RealesrganItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRealesrganModelsSdapiV1RealesrganModelsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Samplers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSamplersSdapiV1SamplersGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SamplerItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSamplersSdapiV1SamplersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Sd Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSdModelsSdapiV1SdModelsGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SDModelItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSdModelsSdapiV1SdModelsGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Get Upscalers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getUpscalersSdapiV1UpscalersGet(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<UpscalerItem>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getUpscalersSdapiV1UpscalersGet(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Img2Imgapi
         * @param {StableDiffusionProcessingImg2Img} stableDiffusionProcessingImg2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img: StableDiffusionProcessingImg2Img, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ImageToImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Interrogateapi
         * @param {InterrogateRequest} interrogateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interrogateapiSdapiV1InterrogatePost(interrogateRequest: InterrogateRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interrogateapiSdapiV1InterrogatePost(interrogateRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Interruptapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async interruptapiSdapiV1InterruptPost(options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.interruptapiSdapiV1InterruptPost(options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Pnginfoapi
         * @param {PNGInfoRequest} pNGInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest: PNGInfoRequest, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<PNGInfoResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Progressapi
         * @param {boolean} [skipCurrentImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async progressapiSdapiV1ProgressGet(skipCurrentImage?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProgressResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.progressapiSdapiV1ProgressGet(skipCurrentImage, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Set Config
         * @param {Options} options 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async setConfigSdapiV1OptionsPost(options: Options, _options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<any>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.setConfigSdapiV1OptionsPost(options, _options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * 
         * @summary Text2Imgapi
         * @param {StableDiffusionProcessingTxt2Img} stableDiffusionProcessingTxt2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img: StableDiffusionProcessingTxt2Img, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<TextToImageResponse>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * DefaultApi - factory interface
 * @export
 */
export const DefaultApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = DefaultApiFp(configuration)
    return {
        /**
         * 
         * @summary Extras Batch Images Api
         * @param {ExtrasBatchImagesRequest} extrasBatchImagesRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest: ExtrasBatchImagesRequest, options?: any): AxiosPromise<ExtrasBatchImagesResponse> {
            return localVarFp.extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Extras Single Image Api
         * @param {ExtrasSingleImageRequest} extrasSingleImageRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest: ExtrasSingleImageRequest, options?: any): AxiosPromise<ExtrasSingleImageResponse> {
            return localVarFp.extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Artists Categories
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistsCategoriesSdapiV1ArtistCategoriesGet(options?: any): AxiosPromise<Array<string>> {
            return localVarFp.getArtistsCategoriesSdapiV1ArtistCategoriesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Artists
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getArtistsSdapiV1ArtistsGet(options?: any): AxiosPromise<Array<ArtistItem>> {
            return localVarFp.getArtistsSdapiV1ArtistsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Cmd Flags
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCmdFlagsSdapiV1CmdFlagsGet(options?: any): AxiosPromise<Flags> {
            return localVarFp.getCmdFlagsSdapiV1CmdFlagsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Config
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getConfigSdapiV1OptionsGet(options?: any): AxiosPromise<Options> {
            return localVarFp.getConfigSdapiV1OptionsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Face Restorers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFaceRestorersSdapiV1FaceRestorersGet(options?: any): AxiosPromise<Array<FaceRestorerItem>> {
            return localVarFp.getFaceRestorersSdapiV1FaceRestorersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Hypernetworks
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHypernetworksSdapiV1HypernetworksGet(options?: any): AxiosPromise<Array<HypernetworkItem>> {
            return localVarFp.getHypernetworksSdapiV1HypernetworksGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Promp Styles
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPrompStylesSdapiV1PromptStylesGet(options?: any): AxiosPromise<Array<PromptStyleItem>> {
            return localVarFp.getPrompStylesSdapiV1PromptStylesGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Realesrgan Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRealesrganModelsSdapiV1RealesrganModelsGet(options?: any): AxiosPromise<Array<RealesrganItem>> {
            return localVarFp.getRealesrganModelsSdapiV1RealesrganModelsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Samplers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSamplersSdapiV1SamplersGet(options?: any): AxiosPromise<Array<SamplerItem>> {
            return localVarFp.getSamplersSdapiV1SamplersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Sd Models
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSdModelsSdapiV1SdModelsGet(options?: any): AxiosPromise<Array<SDModelItem>> {
            return localVarFp.getSdModelsSdapiV1SdModelsGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Get Upscalers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUpscalersSdapiV1UpscalersGet(options?: any): AxiosPromise<Array<UpscalerItem>> {
            return localVarFp.getUpscalersSdapiV1UpscalersGet(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Img2Imgapi
         * @param {StableDiffusionProcessingImg2Img} stableDiffusionProcessingImg2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img: StableDiffusionProcessingImg2Img, options?: any): AxiosPromise<ImageToImageResponse> {
            return localVarFp.img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Interrogateapi
         * @param {InterrogateRequest} interrogateRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interrogateapiSdapiV1InterrogatePost(interrogateRequest: InterrogateRequest, options?: any): AxiosPromise<any> {
            return localVarFp.interrogateapiSdapiV1InterrogatePost(interrogateRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Interruptapi
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        interruptapiSdapiV1InterruptPost(options?: any): AxiosPromise<any> {
            return localVarFp.interruptapiSdapiV1InterruptPost(options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Pnginfoapi
         * @param {PNGInfoRequest} pNGInfoRequest 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest: PNGInfoRequest, options?: any): AxiosPromise<PNGInfoResponse> {
            return localVarFp.pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Progressapi
         * @param {boolean} [skipCurrentImage] 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        progressapiSdapiV1ProgressGet(skipCurrentImage?: boolean, options?: any): AxiosPromise<ProgressResponse> {
            return localVarFp.progressapiSdapiV1ProgressGet(skipCurrentImage, options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Set Config
         * @param {Options} options 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        setConfigSdapiV1OptionsPost(options: Options, _options?: any): AxiosPromise<any> {
            return localVarFp.setConfigSdapiV1OptionsPost(options, _options).then((request) => request(axios, basePath));
        },
        /**
         * 
         * @summary Text2Imgapi
         * @param {StableDiffusionProcessingTxt2Img} stableDiffusionProcessingTxt2Img 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img: StableDiffusionProcessingTxt2Img, options?: any): AxiosPromise<TextToImageResponse> {
            return localVarFp.text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * DefaultApi - object-oriented interface
 * @export
 * @class DefaultApi
 * @extends {BaseAPI}
 */
export class DefaultApi extends BaseAPI {
    /**
     * 
     * @summary Extras Batch Images Api
     * @param {ExtrasBatchImagesRequest} extrasBatchImagesRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest: ExtrasBatchImagesRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).extrasBatchImagesApiSdapiV1ExtraBatchImagesPost(extrasBatchImagesRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Extras Single Image Api
     * @param {ExtrasSingleImageRequest} extrasSingleImageRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest: ExtrasSingleImageRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).extrasSingleImageApiSdapiV1ExtraSingleImagePost(extrasSingleImageRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Artists Categories
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getArtistsCategoriesSdapiV1ArtistCategoriesGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getArtistsCategoriesSdapiV1ArtistCategoriesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Artists
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getArtistsSdapiV1ArtistsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getArtistsSdapiV1ArtistsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Cmd Flags
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getCmdFlagsSdapiV1CmdFlagsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getCmdFlagsSdapiV1CmdFlagsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Config
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getConfigSdapiV1OptionsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getConfigSdapiV1OptionsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Face Restorers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getFaceRestorersSdapiV1FaceRestorersGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getFaceRestorersSdapiV1FaceRestorersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Hypernetworks
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getHypernetworksSdapiV1HypernetworksGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getHypernetworksSdapiV1HypernetworksGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Promp Styles
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getPrompStylesSdapiV1PromptStylesGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getPrompStylesSdapiV1PromptStylesGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Realesrgan Models
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getRealesrganModelsSdapiV1RealesrganModelsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getRealesrganModelsSdapiV1RealesrganModelsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Samplers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSamplersSdapiV1SamplersGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSamplersSdapiV1SamplersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Sd Models
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getSdModelsSdapiV1SdModelsGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getSdModelsSdapiV1SdModelsGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Get Upscalers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public getUpscalersSdapiV1UpscalersGet(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).getUpscalersSdapiV1UpscalersGet(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Img2Imgapi
     * @param {StableDiffusionProcessingImg2Img} stableDiffusionProcessingImg2Img 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img: StableDiffusionProcessingImg2Img, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).img2imgapiSdapiV1Img2imgPost(stableDiffusionProcessingImg2Img, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Interrogateapi
     * @param {InterrogateRequest} interrogateRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public interrogateapiSdapiV1InterrogatePost(interrogateRequest: InterrogateRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).interrogateapiSdapiV1InterrogatePost(interrogateRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Interruptapi
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public interruptapiSdapiV1InterruptPost(options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).interruptapiSdapiV1InterruptPost(options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Pnginfoapi
     * @param {PNGInfoRequest} pNGInfoRequest 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest: PNGInfoRequest, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).pnginfoapiSdapiV1PngInfoPost(pNGInfoRequest, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Progressapi
     * @param {boolean} [skipCurrentImage] 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public progressapiSdapiV1ProgressGet(skipCurrentImage?: boolean, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).progressapiSdapiV1ProgressGet(skipCurrentImage, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Set Config
     * @param {Options} options 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public setConfigSdapiV1OptionsPost(options: Options, _options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).setConfigSdapiV1OptionsPost(options, _options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * 
     * @summary Text2Imgapi
     * @param {StableDiffusionProcessingTxt2Img} stableDiffusionProcessingTxt2Img 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DefaultApi
     */
    public text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img: StableDiffusionProcessingTxt2Img, options?: AxiosRequestConfig) {
        return DefaultApiFp(this.configuration).text2imgapiSdapiV1Txt2imgPost(stableDiffusionProcessingTxt2Img, options).then((request) => request(this.axios, this.basePath));
    }
}


